# -*- mode: org ; coding: utf-8-unix -*-
# last updated : 2014/11/10.11:37:07


#+TITLE:     clang-server Manual
#+AUTHOR:    yaruopooner
#+EMAIL:     [https://github.com/yaruopooner]
#+OPTIONS:   author:nil timestamp:t |:t \n:t ^:nil


* このドキュメントについて
  clang-serverやlibclangをセルフビルドしたい人向け。
  付属の実行ファイルを利用する場合は読まなくても問題ありません。

* libclang について
  clang-serverで使われているlibclangはパッチが当てられています。
  clang-server付属のlibclang-x86_64.libはパッチ適用済みです。
  clang-serverのみをセルフビルドしlibclangは付属のlibを使用する場合は問題ありません。

  セルフビルドLLVMのlibclangを使用する場合は注意が必要です。
  最新のLLVMを適用する場合やlibclangデバッグビルドを作りたい場合は自分でパッチを当てる必要があります。
  パッチを当てないままac-clangでclang-serverを利用する場合、以下の制限事項が発生します。
  
* オフィシャルのlibclangを使用する場合の制限事項
  以下の問題はlibclangにカスタムパッチを当てて改善している。
  file:./clang-server/binary
  においてあるlibclang-x86_XX.dllを使用している場合は発生しない。
  セルフビルドを使う場合はこの問題は発生する。
  clang側の仕様バグなので現在LLVM bugzilla に報告済み。対応待ち中。
  http://llvm.org/bugs/show_bug.cgi?id=20880

** 特定ファイルがロックされセーブできなくなる
   編集したヘッダファイルをセーブしようとすると "basic-save-buffer-2: Opening output file: invalid argument `HEADER-FILE-NAME`" となりセーブできない。
   必ず発生するわけではなく特定の条件を満たしたファイルサイズが16kBを越えるヘッダファイルで発生する。
   16kB以下のヘッダファイルではまったく発生しない。
   libclang の TranslationUnit(以下TU) の問題。
   libclang の TU がinclude対象のファイルをロックしている。
   ac-clang側で暫定対処パッチを施してあるので多少は緩和されているが完全に回避はできない。
   発生した場合はマニュアル対処する以外ない。

*** 対処方法
    include対象なので大抵は foo.cpp/foo.hpp という構成だとおもわれます。
    foo.hpp(modified)がセーブできない場合、大抵foo.cppが(modified)になっているのでfoo.cppをセーブしましょう。
    これによりfoo.hppはセーブ可能になるはずです。
    これでもセーブできない場合は、foo.cpp以外のソースでfoo.hppをインクルードしており(modified)になっているバッファがあるはずなので
    それもセーブしましょう。
    また、定義へのジャンプ機能で該当ソースがアクティブ化されている場合は、未編集バッファであってもアクティブ化されています。
    該当バッファを削除してみるか、そのバッファへスイッチして (ac-clang:deactivate) を実行してください。
    これ以外でも16kBを越えるヘッダを編集しようとした際に、そのファイルのcppはオープンしてもいないのにセーブできない場合、
    該当ヘッダファイルを何処か遠いモジュールでインクルードしている場合なども同様の症状になります。
    ライブラリモジュールやフレームワークなどを開発している場合は発生しやすいかもしれません。
    ※ライブラリ・フレームワークはアプリ側からよくincludeされるため。

*** 原因（実装上の問題説明、解決案求む）
    foo.cpp(modified)のとき foo.cppのセッションで
    TUが foo.cpp パース後もincludeされているファイルのロックを保持しつづけている。
    この状態で foo.hpp を編集してセーブしようとするとロックでエラーになる。
    ロックを解除するには、 foo.cpp のTUをリリースする。
    なので foo.cpp セーブ時にセッションは保持した状態で TU だけをリリースして、
    foo.cpp が再び modified になったときに TU を生成するように修正。
    これにより foo.cpp セーブ後であればincludeロックでが全解除されるので foo.hpp がセーブ可能になる。
    当然 foo.cpp 以外に foo.hpp をinclude しているソースでかつ、編集中のバッファがある場合は、
    それら全てを保存しないとロックでは解除されない。

    このロックはopen関数によるロックはではなくWindowsAPIのCreateFileMappingによるロックである。
    libclang FileManagerは16kB以上のファイルをメモリマップドファイルとしてアロケーションする。
    TUがリリースされるとUnmapViewOfFileによりメモリマップドファイルがリリースされるようになりファイルに対して書き込み可能になる。

* パッチ適用と解説
** パッチ
   mmapを使わないようにパッチをあててみる
   適用するのは以下のソース
   clang-trunk/llvm/lib/Support/MemoryBuffer.cpp

#+begin_src C++
   static error_code getOpenFileImpl(int FD, const char *Filename,
                                  OwningPtr<MemoryBuffer> &result,
                                  uint64_t FileSize, uint64_t MapSize,
                                  int64_t Offset, bool RequiresNullTerminator) {
#+end_src

   ↑の関数内で呼ばれる shouldUseMmap によりmmapの使用判断が行われる
#+begin_src C++
   static bool shouldUseMmap(int FD,
                          size_t FileSize,
                          size_t MapSize,
                          off_t Offset,
                          bool RequiresNullTerminator,
                          int PageSize) {
#+end_src
   この関数のresultが常時falseであればmmapは恒久的に使用されない。
   よってこの関数の先頭で
#+begin_src C++
   return false;
#+end_src
   とすればよい。
   以降のコードは#if 0 end するなりすればよい。

** LLVM3.5の追加仕様
   shouldUseMmap,getOpenFileImplに引数IsVolatileSizeが追加された。
   これはshouldUseMmapまで加工なしでパスされ、
   shouldUseMmap先頭において、
#+begin_src C++
   if (IsVolatileSize)
      return false;
#+end_src
   される。
   コメントがついていた
#+begin_src C++
   // mmap may leave the buffer without null terminator if the file size changed
   // by the time the last page is mapped in, so avoid it if the file size is
   // likely to change.
#+end_src

   MMAPはファイルサイズが最後のページがマップされたされた時点で変更された場合はnull終端せずにバッファを残すので、ファイルサイズが変更される可能性がある場合は、それを回避することができる。

   とは言っているものの、想定されていない事態がいろいろあるようで仕様抜けの模様。 
   またバッファ確保系関数の上流で IsVolatileSize が指定されていなかったりコンストラクタのデフォルト値のまま運用されている箇所が何箇所か見受けられた。
   そういった箇所を自前で修正してみたところ従来よりマシになったものの、他にも問題があるようで想定通りにmmapを制御は出来なかった。
   LLVMのファイルシステム・メモリ周りの仕様を完全に把握していないと、ここら辺の修正は厳しいのかもしれない。
   よって現時点においては上記パッチ適用が一番無難なやり方となる。

* セルフビルドに必要なソフトウェア
  以下が必要になります。
** Visual Studio 2013/2012/2010
   どれでもOK

** Subversion
   http://tortoisesvn.net/

   ソリューションビルド時にsvnコマンドラインが呼び出されるのでTortoiseSVNにパスが通っている必要がある。
   checkout/updateだけならcygwinのsvnで可能だがお勧めしない。
   svnを呼び出してリビジョンナンバーなどを埋め込んだヘッダファイルを生成したりするが
   cygwinのsvnだとパス解釈が正しく実行されない場合がありビルド時に該当ファイルがないといわれてしまうケースがある。
   なのでcygwinのshellなどから実行しないほうがよい。

** cmake
   http://www.cmake.org/

   Windows ZIPをダウンロードして何処かへ展開。
   Visual Studio ソリューション＆プロジェクトファイル生成と、カスタムビルドステップ時のスクリプト実行で使用される。
   Windows Sourceのほうはおすすめしない。
   自前ビルドしたところ、なぜかジェネレーターにVisual Studio系がなかった。なぜ？
	
** python 2.7.x
   http://www.python.org/
   http://www.python.org/download/

   Python 2.7.x Windows X86-64 Installer を使用
   3.x 系は使用しない。
   cmake で LLVMのソリューションファイルを生成する際に必要。

** GnuWin32
   http://gnuwin32.sourceforge.net/
   http://sourceforge.net/projects/getgnuwin32/files/

   カスタムビルドステップで使用される。
   grepなどを使用している模様。

   PATHに GnuWin32/bin を設定する場合は最後尾にしてパス検索順の最後にする。
   Visual Studio GUIからビルドする場合はシステム環境変数のPATHへ追加しておく必要がある。
   環境変数を汚したくない場合はMSBuildでビルドするのがよい。
   MSBuildの場合は、ビルド実行直前に GnuWin32/bin にパスを通せばよいので、
   呼び出しbat内でset PATH=c:\GnuWin32\bin;%PATH%
   などとしておけばよい。

* セルフビルド
** チェックアウト
   自前でチェックアウトしてcmakeでLLVMソリューションファイルを生成するか、以下のpowershellを使用してください。
   https://github.com/yaruopooner/llvm-build-shells
   llvm-build-shellsでは以下を一括で行います。
   - LLVMチェックアウト
   - cmakeによるLLVMソリューションファイル生成
   - Visual Studio(MSBuild)によるビルド
   ビルドするターゲットプラットフォーム(64/32)、コンフィグレーション(release/debug)の指定が可能です。

** 注意
   パッチ以外にLLVMのプロジェクトで変更が必要な箇所がある
   libclangプロジェクトファイルのプロジェクトターゲット名とエクスポートライブラリ名をlibclangからlibclang-x86_64にする必要がある。
   これにより生成されるdll/libのファイル名が変わる。
   libclang.dll -> libclang-x86_64.dll
   libclang.imp -> libclang-x86_64.lib
   デバッグ版や32bit版などは
   libclang.dll -> libclang-x86_64d.dll
   libclang.imp -> libclang-x86_64d.lib
   libclang.dll -> libclang-x86_32.dll
   libclang.imp -> libclang-x86_32.lib
   とした。
   このようにした理由はlibclangの64/32bit版およびそれぞれのデバッグ版を同じディレクトリ内に配置可能にするためです。
   わざわざデバッグビルドとリリースビルドを置き換えるのも手間なので・・。

