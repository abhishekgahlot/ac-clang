# -*- mode: org ; coding: utf-8-unix -*-
# last updated : 2015/07/17.03:12:29


#+TITLE:     Clang Server Manual
#+AUTHOR:    yaruopooner
#+EMAIL:     [https://github.com/yaruopooner]
#+OPTIONS:   author:nil timestamp:t |:t \n:t ^:nil


* About this document
  This is explained about self-build of clang-server.
  When you use clang-server binary for distribution on Windows environment, it is not necessary to read this document.

* Step of self-build
  A build of clang-server requires libclang of LLVM.
  Therefore, first self-build is LLVM libclang, next self-build is clang-server.

** LLVM self-build
   You have to do four step of following.
   There is also a script which simplify this work.
   - Checkout LLVM
   - Apply patch to LLVM for libclang
   - Project file generation by CMAKE or configure
   - Build

** clang-server self-build
   Patch applied libclang library use by LLVM self-build
   Use the patch applied libclang library
   - Project file generation by CMAKE
   - Build
   - Installation

* Software required for self-build
** Windows
   The following is required.
*** LLVM
    The following built library is required.
    libclang.lib or libclang.imp
    libclang.dll

*** Visual Studio 2015/2013/2012/2010
    any OK

*** CMake
    http://www.cmake.org/

    Download cmake archive, and decompress to any location.
    CMake is used for Visual Studio Solution File generation and build and installation.

** Linux
   The following is required.
*** LLVM
    The following built library is required.
    libclang.so

*** CMake
    #+begin_src shell
    $ sudo apt-get install cmake
    #+end_src

    If you want to use latest version, download from following

    http://www.cmake.org/

    e.g.
    Download cmake-3.1.3.tar.gz, and decompress to work directory.
    You perform a build and installation.
    #+begin_src shell
    $ tar -xf cmake-3.1.3.tar.gz .
    $ cd cmake-3.1.3
    $ ./configure && make
    $ make install
    #+end_src

* Self-Build
** Windows
*** LLVM
    Required process for LLVM self-build.
    And you must apply patch to LLVM before build.
    It isn't necessary install a package after self-build.
    You must designate generated binary PATH after LLVM self-build at CMake project generation argument.
    Therefore clang-server is able to build.
    When LLVM is already installed, you must designate installed directory of LLVM.

    When you want to self-build,
    Checkout from SVN by yourself, and perform the LLVM Solution File generation and build by cmake.
    Or, use following script.
    https://github.com/yaruopooner/llvm-build-shells

**** How to designate the LLVM patch in the script
     You will designate -tasks to the argument of builderShell,
     and designate PATCH to the parameter of -tasks,
     It will gives a table that describes the path to apply the patch and patch file to parameter of -patchInfos.
     Please refer to the sample.ps1 of llvm-build-shells for details.

**** The contents of the LLVM patch
     Use of mmap always invalidation.

*** clang-server
    Use the ac-clang/build/builder_sample.bat
    Please edit the builder_sample.bat as necessary.
    It's necessary to execute in the command line or Windows Explorer.
    
    - example
      #+begin_src bat
      cmake -G "Visual Studio 12 2013 Win64" ../clang-server -DLIBRARY_PATHS="c:/cygwin-x86_64/tmp/llvm-build-shells/ps1/clang-360/build/msvc-64/" -DCMAKE_INSTALL_PREFIX="c:/cygwin-x86_64/usr/local/bin/"
      #+end_src

    - Option commentary
      - =-DLIBRARY_PATHS=
        You have to designate location of  LLVM self-build completed directory.
        It is necessary to designate the directory that a binary was generated.(e.g. {LLVM output path}/Release/)
        If you omit this option, value will be use =ac-clang/clang-server= .
      - =-DCMAKE_INSTALL_PREFIX=
        You have to designate installation location of clang-server.
        If you omit this option, value will be use =C:/Program Files/clang-server= .

** Linux
*** LLVM
    Required process for LLVM self-build.
    And you must apply patch to LLVM before build.
    It isn't necessary install a package after self-build.
    You must designate generated binary PATH after LLVM self-build at CMake project generation argument.
    Therefore clang-server is able to build.
    When LLVM is already installed, you must designate installed directory of LLVM.
    
    When you want to self-build,
    Checkout from SVN by yourself, and perform the LLVM Solution File generation and build by cmake.
    Or, use following script.
    https://github.com/yaruopooner/llvm-build-shells
    
**** How to designate the LLVM patch in the script
     You will designate -patch to the argument of executeBuilder.
     Add to -patchApplyLocation the path where you want to apply the patch.
     You write the patch file to -patchPath gives as an parameter.
     -patchApplyLocation,-patchPath becomes the pair, it is possible to multiple times designate.
     Please refer to the sample.sh of llvm-build-shells for details.

**** The contents of the LLVM patch
     Use of mmap always invalidation.

*** clang-server
    Use the ac-clang/build/builder_sample.sh
    Please edit the builder_sample.sh as necessary.
    Execute the builder_sample.sh

    - example
      #+begin_src shell-script
      cmake -G "Unix Makefiles" ../clang-server -DLIBRARY_PATHS="/home/yaruopooner/work/llvm-build-shells/sh/clang-350/build" -DCMAKE_INSTALL_PREFIX="~/work/clang-server"
      #+end_src

    - Option commentary
      - =-DLIBRARY_PATHS=
        You have to designate location of  LLVM self-build completed directory.
        It is necessary to designate the directory that a binary was generated.(e.g. {LLVM output path}/Release/)
        If you omit this option, value will be use =ac-clang/clang-server= .
      - =-DCMAKE_INSTALL_PREFIX=
        You have to designate installation location of clang-server.
        If you omit this option, value will be use =/usr/local/bin= .

* Patch was applied binary(Windows Only)
  https://github.com/yaruopooner/ac-clang/releases

  clang-server-X.X.X.zip is you can download from the above
  The archive is 3 files contain, these file applied patch.
   - clang-server.exe
   - libclang.dll
   - libclang.lib or libclang.imp
   
   When you want to self-build only clang-server without LLVM,
   clang-server-X.X.X.zip decompress to ac-clang directory.
   Then, it will be placed in the following. 
   ac-clang/clang-server/binary/clang-server.exe
   ac-clang/clang-server/library/x86_64/release/libclang.dll
   ac-clang/clang-server/library/x86_64/release/libclang.lib

* Restrictions when you use LLVM official libclang without applying a patch
** A specific file is locked and cannot save it
   編集したヘッダファイルをセーブしようとすると "basic-save-buffer-2: Opening output file: invalid argument `HEADER-FILE-NAME`" となりセーブできない。
   必ず発生するわけではなく特定の条件を満たしたファイルサイズが16kBを越えるヘッダファイルで発生する。
   16kB以下のヘッダファイルではまったく発生しない。
   libclang の TranslationUnit(以下TU) の問題。
   libclang の TU がinclude対象のファイルをロックしている。
   ac-clang側で暫定対処パッチを施してあるので多少は緩和されているが完全に回避はできない。
   発生した場合はマニュアル対処する以外ない。

*** emacs側での対処方法
    include対象なので大抵は foo.cpp/foo.hpp という構成だとおもわれます。
    foo.hpp(modified)がセーブできない場合、大抵foo.cppが(modified)になっているのでfoo.cppをセーブしましょう。
    これによりfoo.hppはセーブ可能になるはずです。
    これでもセーブできない場合は、foo.cpp以外のソースでfoo.hppをインクルードしており(modified)になっているバッファがあるはずなので
    それもセーブしましょう。
    また、定義へのジャンプ機能で該当ソースがアクティブ化されている場合は、未編集バッファであってもアクティブ化されています。
    該当バッファを削除してみるか、そのバッファへスイッチして (ac-clang-deactivate) を実行してください。
    これ以外でも16kBを越えるヘッダを編集しようとした際に、そのファイルのcppはオープンしてもいないのにセーブできない場合、
    該当ヘッダファイルを何処か遠いモジュールでインクルードしている場合なども同様の症状になります。
    ライブラリモジュールやフレームワークなどを開発している場合は発生しやすいかもしれません。
    ※ライブラリ・フレームワークはアプリ側からよくincludeされるため。

*** 原因（実装上の問題説明、解決案求む）
    foo.cpp(modified)のとき foo.cppのセッションで
    TUが foo.cpp パース後もincludeされているファイルのロックを保持しつづけている。
    この状態で foo.hpp を編集してセーブしようとするとロックでエラーになる。
    ロックを解除するには、 foo.cpp のTUをリリースする。
    なので foo.cpp セーブ時にセッションは保持した状態で TU だけをリリースして、
    foo.cpp が再び modified になったときに TU を生成するように修正。
    これにより foo.cpp セーブ後であればincludeロックでが全解除されるので foo.hpp がセーブ可能になる。
    当然 foo.cpp 以外に foo.hpp をinclude しているソースでかつ、編集中のバッファがある場合は、
    それら全てを保存しないとロックでは解除されない。

    Windows環境において、
    このロックはI/Oのopen関数によるロックはではなくWindowsAPIのCreateFileMappingによるロックである。
    libclang FileManagerは16kB以上のファイルをメモリマップドファイルとしてアロケーションする。
    TUがリリースされるとUnmapViewOfFileによりメモリマップドファイルがリリースされるようになりファイルに対して書き込み可能になる。

    Linux環境においても発現する不具合はWindows環境と若干異なるものの mmap/munmapによる問題は発生する。
    foo.cppのTUを保持している状態でfoo.hppにおいてclass fooのメソッドを追加・削除し保存する。
    foo.hpp更新後にfoo.cppにおいてclass fooのメソッドを補間しようとするとTUがクラッシュする。
    libclangがSTDOUTに "libclang: crash detected in code completion" を出力する。
    clang-serverのプロセスは生きており、セッションを破棄して再生成すれば補間続行は可能。

** Miscellaneous
   上記の問題はlibclangにパッチを適用して改善している。
   
   パッチを適用したリリースバイナリのlibclang-x86_XX.(dll or so)を使用している場合は発生しない。
   パッチを適用していないLLVMセルフビルドおよび、LLVMオフィシャルバイナリを使用する場合にのみ問題が発生します。
   clang側の仕様バグなので現在LLVM bugzilla に報告済み。対応待ち中。
   http://llvm.org/bugs/show_bug.cgi?id=20880

* Patch commentary
** Patch
   Use the ac-clang/clang-server/patch/invalidate-mmap.patch
   #+begin_src shell-script
   cd llvm/
   svn patch ac-clang/clang-server/patch/invalidate-mmap.patch
   #+end_src

** The contents of the LLVM patch(invalidate-mmap.patch)
   Patch is applied so as not to use mmap.
   Apply to the following source code to 
   =clang-trunk/llvm/lib/Support/MemoryBuffer.cpp=

#+begin_src C++
   static error_code getOpenFileImpl(int FD, const char *Filename,
                                  OwningPtr<MemoryBuffer> &result,
                                  uint64_t FileSize, uint64_t MapSize,
                                  int64_t Offset, bool RequiresNullTerminator) {
#+end_src

   ↑の関数内で呼ばれる shouldUseMmap によりファイルに対するmmapの使用可否が判断される
#+begin_src C++
   static bool shouldUseMmap(int FD,
                          size_t FileSize,
                          size_t MapSize,
                          off_t Offset,
                          bool RequiresNullTerminator,
                          int PageSize) {
#+end_src
   この関数のresultが常時falseであればmmapは恒久的に使用されない。
   よってこの関数の先頭で
#+begin_src C++
   return false;
#+end_src
   とすればよい。
   以降のコードは#if 0 end するなりすればよい。

** LLVM3.5の追加仕様
   shouldUseMmap,getOpenFileImplに引数IsVolatileSizeが追加された。
   これはshouldUseMmapまで加工なしでパスされ、
   shouldUseMmap先頭において、
#+begin_src C++
   if (IsVolatileSize)
      return false;
#+end_src
   される。
   コメントがついていた
#+begin_src C++
   // mmap may leave the buffer without null terminator if the file size changed
   // by the time the last page is mapped in, so avoid it if the file size is
   // likely to change.
#+end_src

   mmapはファイルサイズが最後のページがマップされたされた時点で変更された場合はnull終端せずにバッファを残すので、ファイルサイズが変更される可能性がある場合は、それを回避することができる。

   とは言っているものの、想定されていない事態がいろいろあるようで仕様抜けの模様。 
   またバッファ確保系関数の上流で IsVolatileSize が指定されていなかったりコンストラクタのデフォルト値のまま運用されている箇所が何箇所か見受けられた。
   そういった箇所を自前で修正してみたところ従来よりマシになったものの、他にも問題があるようで想定通りにmmapを制御は出来なかった。
   LLVMのファイルシステム・メモリ周りの仕様を完全に把握していないと、ここら辺の修正は厳しいのかもしれない。
   よって現時点においては上記パッチ適用が一番無難なやり方となる。

